#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTGYRO,         sensorAnalogInactive)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     FourBar,       tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* This code is for a simple tank drive motor setup with all motors wired + = red, - = black.
A motor controller with the drive motors is wired directly to the NXT input1 (motors D and E
are drive motors.  A second motor controller is daisy chained to the first.  The four bar
motor is wired into motor 2.  A servo controller is daisy chained to the second motor controller.
Two servos are plugged into ports 1 and 2 to move the Vcup.

The HiTechnic protoboard has two limit switches wired into Analog0 and Analog 2 inputs.
The protoboard is plugged into input2 on the NXT.

Two joysticks run this robot.  Joystick 1 is tank drive for the drive motors on the two
joysticks.  Button 5 on joystick one is turbo.  Button 6 on joystick one is slow.

Joystick 2 runs the four bar and the Vcup.  The 2nd joystick is the
power for the f-bar.  Up moves the fourbar up.  Down moves it down.

Buttons 5 and 6 on the 2nd joystick move the Vcup up or down by increments
of 10 servo counts (about 8 degrees).

Debugging information:
line 1: servos, first is #1, second is #2
line 2: drive power: leftpower then rightpower
line 3: 4-bar encoder position
line 4: limit switch signals (0 means OK, 1 means too high, 2 means too low)

*/

#include "JoystickDriver.c"
#include "../common/drivers/hitechnic-protoboard.h"
int GlobalTargetPosition = 1;

int fourbarpower = 0;  //motor power for the 4bar motor
int servoposition1 = 128;  //servo positions
int servoposition2 = 122;
bool Override = false;
#ifdef DEBUG_ENABLED
int debug = 1;
#else
int debug = 0;		//set to zero to turn off debug
#endif

float leftpower = 0;	//drive motor powers
float rightpower = 0;

int fourbarposition = 1;
const int ArmSpeed = 50;
#include "../common/ArmLibrary.h"

/////////////////////////////////////BASIC TANK DRIVE////////////////////////////////////////////////////////////////////
void tankdrive()
{
	rightpower = joystick.joy1_y2*100/128;		//read joystick y values (both sticks)
	leftpower = joystick.joy1_y1*100/128;

	if(abs(rightpower) < 8)			//deadband with threshold of 8

	{
		rightpower = 0;
	}

	if(abs(leftpower) < 8)			//deadband with threshold of 8

	{
		leftpower = 0;
	}
	//if(debug) {nxtDisplayString(1, "drive: %i, %i", leftpower, rightpower);}
	motor[motorD] = .7 * leftpower;		//TURN LEFTDRIVE AT leftpower
	motor[motorE] = .7 * rightpower;		//TURN RIGHTDRIVE AT rightpower
}



int PositionToCounts(int s)
{
	int Position0 = 0;
	int Position1 = -50;
	int Position2 = -600;
	int Position3 = -2600;
	int Position4 = -2900;
	if (s == 0)
	{
		return Position0;
	}
	if (s == 1)
	{
		return Position1;
	}
	if (s == 2)
	{
		return Position2;
	}
	if (s == 3)
	{
		return Position3;
	}
	if (s == 4)
	{
		return Position4;
	}
	return -1.1;
}
void MoveServoForPosition(int p)
{
	if (p == 1 || p == 3)
	{
		MoveVCupToPosition(70);
	}
	else
	{
		MoveVCupToPosition(20);
	}
}

void MoveToPosition(int TargetPosition)
{
	nxtDisplayString(2, "%i", PositionToCounts(TargetPosition));
	nxtDisplayString(1, "%i", nMotorEncoder[FourBar]);
	int leftpower2 = joystick.joy2_y1;
	if (joy1Btn(7) == 1 || joy1Btn(8) == 1)
	{
		Override = true;
	}


	if (Override == false)
	{
  MoveServoForPosition(TargetPosition);
	if (nMotorEncoder[FourBar] > PositionToCounts(TargetPosition) + 80)
	{
		motor[FourBar] = -40;
	}
	else if (nMotorEncoder[FourBar] < PositionToCounts(TargetPosition) - 80)
	{
		motor[FourBar] = 40;
	}
	else
	{
		motor[FourBar] = 0;
	}
}
else if (Override == true)
{

			if (joy1Btn(7) == 1)
			{
				motor[FourBar] = 40;
			}
			else if (joy1Btn(8) == 1)
			{
				motor[FourBar] = -40;
			}
			else
			{
				motor[FourBar] = 0;
			}

			if (joy1Btn(5) == 1)
			{
				MoveVCupToPosition(70);
			}
			else if (joy1Btn(6) == 1)
			{
				MoveVCupToPosition(20);
			}

	}
}

//////////////////////////////////////////TASK MAIN///////////////////////////////////////////////////////////////
task main()
{
	#ifndef DEBUG_ENABLED
	bDisplayDiagnostics = false;
	#endif
	nMotorEncoder[FourBar] = 0;

	while(true)
	{
		getJoystickSettings(joystick);

		if (joy1Btn(1) == 1)
		{
			Override = false;
			GlobalTargetPosition = 1;
		}
		else if (joy1Btn(2) == 1)
		{
			Override = false;
			GlobalTargetPosition = 2;
		}
		else if (joy1Btn(3) == 1)
		{
			Override = false;
			GlobalTargetPosition = 3;
		}
		else if (joy1Btn(4) == 1)
		{
			Override = false;
			GlobalTargetPosition = 4;
		}


		//nxtDisplayString(4, "%i", leftpower2);



		MoveToPosition(GlobalTargetPosition);


		//drivespeed();
		tankdrive();

		wait1Msec(50);
		eraseDisplay();

	}
}
